<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://haizei.github.io</id>
    <title>Gridea</title>
    <updated>2021-03-06T11:20:47.895Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://haizei.github.io"/>
    <link rel="self" href="https://haizei.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://haizei.github.io/images/avatar.png</logo>
    <icon>https://haizei.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Linux note]]></title>
        <id>https://haizei.github.io/post/linux-note/</id>
        <link href="https://haizei.github.io/post/linux-note/">
        </link>
        <updated>2021-01-05T14:15:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据结构">数据结构</h1>
<h2 id="二叉排序树">二叉排序树</h2>
<h3 id="一-性质">一、性质</h3>
<ol>
<li>左子树 &lt; 根节点</li>
<li>右子树 &gt; 根节点</li>
<li>中序遍历的结果，是一个有序序列</li>
</ol>
<p>数据结构，就是定义一种性质，并且维护这种性质。</p>
<h3 id="二-插入操作">二、插入操作</h3>
<p>1、 插入新的节点，一定会作为叶子节点</p>
<h3 id="三-删除操作">三、删除操作</h3>
<ol>
<li>删除度为0的节点，直接删除</li>
<li>删除度为1的节点，把『孤儿子树』挂到其父节点上面去</li>
<li>删除度为2的节点，可以转化成删除度为1的节点</li>
</ol>
<p>对于度为2的节点：</p>
<ol>
<li>前驱：左子树最大值</li>
<li>后继：右子树最小值</li>
</ol>
<h3 id="四-随堂练习">四、随堂练习</h3>
<ol>
<li>插入顺序会影响最终的树形结构</li>
<li>不同的树形结构，查找效率不同</li>
</ol>
<p>平均查找效率：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">找</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">期</mi><mi mathvariant="normal">望</mi><mi mathvariant="normal">值</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">总</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">量</mi></mrow></mfrac><mo>(</mo><mi mathvariant="normal">假</mi><mi mathvariant="normal">设</mi><mi mathvariant="normal">每</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">被</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">找</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">节点查找次数的期望值=\frac{总次数}{节点数量} ( 假设每个节点等概率的被查找)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">找</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">期</span><span class="mord cjk_fallback">望</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.436em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">量</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord cjk_fallback">假</span><span class="mord cjk_fallback">设</span><span class="mord cjk_fallback">每</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">被</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">找</span><span class="mclose">)</span></span></span></span></span></p>
<h3 id="五-扩展内容">五、扩展内容</h3>
<ol>
<li>
<p>二叉排序树的删除代码优化</p>
<ol>
<li>删除掉处理度为0的代码逻辑，不影响代码整体功能</li>
</ol>
</li>
<li>
<p>如何解决排名相关的检索需求</p>
<ol>
<li>
<p>修改二叉排序树的结构定义，增加 size 字段，记录每棵树的节点数量</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>L</mi><mi>S</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = LS - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，根节点就是排名第 k 位的元素</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≤</mo><mi>L</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">k \le LS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>  ，排名第 k 位的元素在左子树中</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>L</mi><mi>S</mi><mi mathvariant="normal">，</mi><mi>s</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>c</mi><msub><mi>h</mi><mi>k</mi></msub><mo>(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mo>&gt;</mo><mi>r</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mi>L</mi><mi>S</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">k \gt LS，search_k(root-&gt;rchild, k - LS - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
</ol>
</li>
<li>
<p>解决 Top-K 问题（找到小于第 k 位的所有元素）</p>
<ol>
<li>根节点就是第 k 位元素的话，就把左子树中的值全部输出出来</li>
<li>第 k 位在左子树中，前 k 位元素全都在左子树中</li>
<li>第 k 位在右子树中，说明根节点和左子树中的元素，都是前 k 位元素里面的值</li>
</ol>
</li>
<li>
<p>二叉排序树和快速排序的关系</p>
<ol>
<li>二叉排序树是快速排序在思维逻辑结构层面用的数据结构</li>
<li>思考1：快速排序的时间复杂度和二叉排序树建树时间复杂度之间的关系</li>
<li>思考2：快速选择算法和二叉排序树之间的关系</li>
<li>程序=算法+数据结构</li>
</ol>
</li>
</ol>
<p>所谓算法设计及分析能力：分类讨论及归纳总结的能力</p>
<p>leetcode</p>
<h2 id="哈希表">哈希表</h2>
<ol>
<li>
<p>映射</p>
</li>
<li>
<p>冲突处理： 哈希之后，所要存储的位置已有元素，有以下几种处理方案；</p>
<ol>
<li>
<p>开放定值法：哈希之后，所要存储的位置已有元素，则沿当前位置往后寻找，直至空位，进行存储；二次探测法等(常用)</p>
</li>
<li>
<p>再哈希法：设置多种哈希函数，当第一种哈希函数冲突时，使用第其余哈希函数进行哈希，从而避免冲突；</p>
</li>
<li>
<p>链表存储：哈希位置存放非单个元素，而是链表，则可以有效避免冲突，现大多采用此种方法避免冲突；（常用）可能会产生数据堆积的后果，浪费空间；</p>
</li>
<li>
<p>建立公共溢出区：将冲突元素全部加入到公共溢出区，避免冲突；</p>
</li>
</ol>
</li>
</ol>
<p>练习题： leetcode 01 03 04 21 35 38 88 217 219 278 349 350 374 378</p>
<p>哈希表的空间利用率通常为50% ~ 90% , 当空间利用率达到70%以上时便可应用于工业。</p>
<p>BKDRhash hash = hash ＊　size  + str[i];</p>
<h2 id="红黑树">红黑树</h2>
<p>与AVL相比，平衡控制更加松散，为的是插入更多的数据，更少的调整。</p>
<h3 id="一-平衡条件">一、平衡条件</h3>
<ol>
<li>每个节点非黑即红</li>
<li>根节点是黑色</li>
<li>叶节点（NIL）是黑色</li>
<li><mark>如果一个节点是红色，则它的两个子节点都是黑色的</mark></li>
<li><mark>从根节点出发到所有叶节点路径上，黑色节点数量相同</mark></li>
</ol>
<p>第4条和第5条条件，决定了红黑树中最长路径是最短路径的长度的2倍。</p>
<p>本质上，红黑树也是通过树高来控制平衡的。</p>
<p>红黑树比AVL树树高控制条件要更加松散，红黑树在发生节点插入和删除以后，发生调整的概率要比AVL树要更小。</p>
<h3 id="二-学习诀窍">二、学习诀窍</h3>
<ol>
<li>理解红黑树的插入调整，要站在<mark>祖父节点</mark>向下调整</li>
<li>理解红黑树的删除调整，要站在<mark>父节点</mark>向下进行调整</li>
<li>插入调整，主要就是为了解决双红情况</li>
<li>新插入的节点一定是红色，插入黑色节点一定会产生冲突，违反条件5，插入红色节点，不一定产生冲突</li>
<li>把每一种情况，想象成一颗大的红黑树中的局部子树</li>
<li>局部调整的时候，为了不影响全局，调整前后的路径上的黑色节点数量相同</li>
</ol>
<h3 id="三-调整策略">三、调整策略</h3>
<p><mark>调整之前路径上黑色节点数量等于调整之后黑色节点的数量</mark></p>
<ol>
<li>插入站在<code>祖父节点</code>看 （参考AVL的调整。同样的树高）</li>
<li>删除调整站在<mark>父节点</mark>看</li>
<li>插入和删除的情况处理一共5种</li>
</ol>
<p>情况一和情况二又可细分4种小情况</p>
<p>LL, RR , RL , LR</p>
<p>情况一</p>
<h3 id="四-插入策略">四、插入策略</h3>
<ol>
<li>叔叔节点为红色的时候，修改三元组小帽子，改成红黑黑。</li>
<li>叔叔节点为黑色的时候，参考AVL失衡情况，分成LL， LR， RL，RR，先参考AVL树的旋转调整策略，然后在修改三元组的颜色，有两种调整策略： 红色上浮，红色下沉。</li>
<li>两大类情况，包含8种小情况。</li>
</ol>
<h3 id="下">（下）</h3>
<p>一、删除调整发生的前提</p>
<ol>
<li>删除红色节点，不会对红黑树的平衡产生影响</li>
<li>度为1的黑色节点，唯一子孩子， 一定是红色。</li>
<li>删除度为1的黑色节点，不会删除</li>
</ol>
<h3 id="红黑树和avl树对比">红黑树和AVL树对比</h3>
<p>查找：AVL更加平衡，所以效率更高</p>
<p>插入：红黑树的调整时更多的进行是染色，左右旋的次数少，提升插入，删除效率。</p>
<p>在工业上插入。</p>
<h2 id="哈夫曼编码">哈夫曼编码</h2>
<h1 id="linux">Linux</h1>
<p>command : &quot;w&quot; display now connection user</p>
<p>向该用户发送你好</p>
<p>echo &quot;hello&quot; &gt;&gt; /dev/pts/1</p>
<p>tr &quot;aaa&quot; &quot;bbb&quot; 将aaa替换成bbb</p>
<h2 id="apt">apt</h2>
<p>apt update （同步软件信息，有哪些软件可用，那些软件可以更新，哪些可以卸载）</p>
<p>apt upgrade （更新本地软件为最新版本）</p>
<p>apt-cache search XXX （搜索xxx软件）</p>
<p>apt remove XXX (删除xxx软件)</p>
<p>apt remove XXX --purge (清除用户信息（彻底删除)</p>
<p>dpkg -i xxx.deb (使用dpkg程序安装xxx.deb) (安装=install -&gt; -i)</p>
<p>dpkg -r (使用dpkg卸载软件) （卸载=remove -&gt; -r)</p>
<p>epoll</p>
<p>man -k xxx</p>
<p>man -f xxx</p>
<p>cat &gt;&gt; a.log &lt;&lt; haha  当输入haha时结束输入</p>
<p>统计登录用户信息，数据清洗</p>
<p>last | grep -v &quot;wtmp begins&quot; | grep -v &quot;^$&quot; | cut -d ' ' -f 1 | sort |  uniq -c |  sort -n -r | head -n 1</p>
<p>-v 取反</p>
<p>^行开始</p>
<p>$行结束</p>
<p>“^$&quot;空行</p>
<p>cut -d ‘ ’ 以空格为分割， -f 1 取第一个</p>
<p>uniq -c 去重并计数</p>
<p>sort -n 以数字大小排序， -r 由大到小输出</p>
<p>head -n x 显示前x行</p>
<p>词频统计</p>
<p>cat xxx | tr -s -c &quot;a-zA-Z&quot; &quot;\n&quot; | sort | uniq -c | sort -n | more</p>
<p>按后面格式输出当前系统时间</p>
<p>date +&quot;%Y-%m-%d %H:%M:%S&quot;</p>
<p>$[] 整数计算</p>
<pre><code class="language-bash">Ontime=`data +&quot;%s&quot;`
echo ${Ontime}
Nowtime=`data + &quot;%s&quot;`
Onlinetime=$[{$Nowtime}-{$Ontime}]
</code></pre>
<p>echo -e &quot;\033[31;34m;34m123\033[0m456&quot;</p>
<p>-e 打开转义</p>
<p>NPT 网络时间协议</p>
<p>特殊变量</p>
<p>$0:获取当前执行shell脚本的文件名，包括路径</p>
<p>$n:获取当前执行脚本的第n个参数，n=1...9, 如果n&gt;9,则需要将n使用{}括起来</p>
<p>$*:获取当前shell的所有参数，将所有命令行参数视为单个字符串，相当于&quot;$1$2$3&quot;;</p>
<p>$#:得到执行当前脚本的参数个数；</p>
<p>$@:获取这个程序所有参数，并保留参数之间的任何空白，相当于&quot;$1&quot; &quot;$2&quot; &quot;$3&quot;,这是将参数传给其他程序的最好办法</p>
<p>$?:判断上一直令是否成功执行，0为成功，非零为不成功</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 13: :取当前进程的PID

$̲!:上一个指令的PID



…'>:取当前进程的PID

$!:上一个指令的PID



read  -s -p prompt  - t 2 xxx

提示prompt 静默输入 超时两秒自动结束

## shell编程

### 函数

```bash
function __printf__() {
	echo &quot;$1&quot;
	return
}

__printf__ &quot;hello handsomeboy&quot;
```



### 条件语句

```bash
#!/bin/bash
read -p &quot;输入任意数字： &quot; a
if [[ ${a} -lt 10 ]];then
    echo &quot;$a &lt; 10&quot;
elif [[ ${a} -eq 10 ]];then
	echo &quot;$a = 10&quot;
else
    echo &quot;$a &gt; 10&quot;
fi

```

### 流程控制

```bash
#!/bin/bash
read a
case $a in
    1)
        echo 1
        ;;
    2)
        echo 2
        ;;
esac
```

### 循环

```bash
#!/bin/bash
for i in `seq 1 100`;do
	touch file${i}.txt
	done
	
```

```bash
#!/bin/bash
num=0
while [[ $num -lt 100 ]];do
    echo ${num}
    num=$[ ${num} + 1 ]
done

```

```bash
#!/bin/bash
num=0
until [[ $num -eq 100 ]];do
    echo $num
    num=$[ ${num} + 1 ]
done

```

```bash
#!/bin/bash
for (( i=1; i&lt;=100; i++ ));do
    if [[ $[ ${i} % 2 ] -eq 0 ]];then
        sum=$[ ${sum} + ${i} ]
    fi
done

echo &quot;sum = ${sum}&quot;

```

### 数组

1. declare -a a
2. name[subscript]=value
3. name=(value1 value2...)

#### 数组操作

1. 输出数组内容

   ${arry[*]}

   ${arry[@]}

2. 确定数组元素个数

   ${#arry[@]}

3. 找到数组的下标

   ${!arry[@]}

4. 数组追加

   arry+=(a b c)

5. 数组排序

   sort

6. 删除数组与元素

   unset



#### 操作实例

```bash
declare -a b
b[1]=1
b[2]=3
echo ${b[@]}
echo ${b[*]}
echo ${#b[*]}

or
c[1]=1
c[2]=2
echo ${c[*]}

or
files=(`ls`)
ehco ${#files[*]} #文件名中有空格时与ls | wc -l结果不同
```

==bash中数组下标不一定连续，可由自己设置离散的数组==







### debug

bash xxx -x 会将每一步都打印出来

在shell脚本内部：

```bash
set +x
kkkkkkk
set -x
```

将kkkkkkk打印出来



### find

杀掉某个用户的全部进程，

```bash
kill `find /proc/ -mmin -10 -user xxx 2&gt;/dev/null | cut -d &#039;/&#039; -f 2 | uniq`
```



查看自己当前目录下所有的代码行数

```bash
find . -name \( &quot;*.c&quot; -o &quot;*.cpp&quot; \) -exec cat {} \; | wc -l

```



### Linux三剑客

#### grep

#### awk

学习参考网站

[学习]: https://awk.readthedocs.io/en/latest/index.html

统计用户登录时长

```bash
last | grep -v &quot;^$&quot; | grep -v &quot;wtmp&quot; | grep -v &quot;still&quot; | awk &#039;{ if ($1 ==  &quot;hhl&quot; ) {print $10} }&#039; | cut -c 2-6 | awk -F: -v hour=0 -v min=0 &#039;{hour+=$1;min+=$2} END{{hour+=(min/60);min=min%60} printf(&quot;%d hours, %d mins\n&quot;,hour,min)}&#039;

```

awk &#039;&#039; 为单引号

#### sed

### 词频统计



## vim操作

批量插入列: 

1. Ctrl + v 进入可视块模式
2. 选中后Shitf+i进入插入模式
3. 输入要插入的内容按ESC进行列插入



# question

## linux 

1. 使用cron设置定时任务
2. Tmux
3. epoll



# Task

## Linux 

### 登录信息提示

1. 在每次通过远程连接进入系统时，告知用户如下信息：
   1. 最近一段时间，当前用户，也就是你，登录了多少次`last`
   2. 上一次登录系统，停留了多少时间
   3. 给用户推荐一句名人名言，唐诗三百首之类的
   4. 最好还能告知一下当地当日天气预报
   5. 一个温馨的问候，毕竟是==女朋友==
2. 要求显示美观，有一定的颜色

#### 完成过程

1. 使用man zsh (/FILE)查询启动zsh时的相关文件
2. 修改相关的ZSH文件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[rqwr ]]></title>
        <id>https://haizei.github.io/post/rqwr/</id>
        <link href="https://haizei.github.io/post/rqwr/">
        </link>
        <updated>2021-01-05T13:31:28.000Z</updated>
        <content type="html"><![CDATA[<p>vaf<img src="https://haizei.github.io/post-images/1609853513605.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://haizei.github.io/post/hello-gridea/</id>
        <link href="https://haizei.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>