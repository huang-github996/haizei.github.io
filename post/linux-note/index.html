<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux note | Gridea</title>
<link rel="shortcut icon" href="https://haizei.github.io/favicon.ico?v=1615029554572">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://haizei.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Linux note | Gridea - Atom Feed" href="https://haizei.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="数据结构
二叉排序树
一、性质

左子树 &lt; 根节点
右子树 &gt; 根节点
中序遍历的结果，是一个有序序列

数据结构，就是定义一种性质，并且维护这种性质。
二、插入操作
1、 插入新的节点，一定会作为叶子节点
三、删除操作

删..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://haizei.github.io">
  <img class="avatar" src="https://haizei.github.io/images/avatar.png?v=1615029554572" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Linux note
            </h2>
            <div class="post-info">
              <span>
                2021-01-05
              </span>
              <span>
                12 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="数据结构">数据结构</h1>
<h2 id="二叉排序树">二叉排序树</h2>
<h3 id="一-性质">一、性质</h3>
<ol>
<li>左子树 &lt; 根节点</li>
<li>右子树 &gt; 根节点</li>
<li>中序遍历的结果，是一个有序序列</li>
</ol>
<p>数据结构，就是定义一种性质，并且维护这种性质。</p>
<h3 id="二-插入操作">二、插入操作</h3>
<p>1、 插入新的节点，一定会作为叶子节点</p>
<h3 id="三-删除操作">三、删除操作</h3>
<ol>
<li>删除度为0的节点，直接删除</li>
<li>删除度为1的节点，把『孤儿子树』挂到其父节点上面去</li>
<li>删除度为2的节点，可以转化成删除度为1的节点</li>
</ol>
<p>对于度为2的节点：</p>
<ol>
<li>前驱：左子树最大值</li>
<li>后继：右子树最小值</li>
</ol>
<h3 id="四-随堂练习">四、随堂练习</h3>
<ol>
<li>插入顺序会影响最终的树形结构</li>
<li>不同的树形结构，查找效率不同</li>
</ol>
<p>平均查找效率：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">找</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">期</mi><mi mathvariant="normal">望</mi><mi mathvariant="normal">值</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">总</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">量</mi></mrow></mfrac><mo>(</mo><mi mathvariant="normal">假</mi><mi mathvariant="normal">设</mi><mi mathvariant="normal">每</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">被</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">找</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">节点查找次数的期望值=\frac{总次数}{节点数量} ( 假设每个节点等概率的被查找)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">找</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">期</span><span class="mord cjk_fallback">望</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.436em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">量</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord cjk_fallback">假</span><span class="mord cjk_fallback">设</span><span class="mord cjk_fallback">每</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">被</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">找</span><span class="mclose">)</span></span></span></span></span></p>
<h3 id="五-扩展内容">五、扩展内容</h3>
<ol>
<li>
<p>二叉排序树的删除代码优化</p>
<ol>
<li>删除掉处理度为0的代码逻辑，不影响代码整体功能</li>
</ol>
</li>
<li>
<p>如何解决排名相关的检索需求</p>
<ol>
<li>
<p>修改二叉排序树的结构定义，增加 size 字段，记录每棵树的节点数量</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>L</mi><mi>S</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = LS - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，根节点就是排名第 k 位的元素</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≤</mo><mi>L</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">k \le LS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>  ，排名第 k 位的元素在左子树中</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>L</mi><mi>S</mi><mi mathvariant="normal">，</mi><mi>s</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>c</mi><msub><mi>h</mi><mi>k</mi></msub><mo>(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mo>&gt;</mo><mi>r</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mi>L</mi><mi>S</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">k \gt LS，search_k(root-&gt;rchild, k - LS - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
</ol>
</li>
<li>
<p>解决 Top-K 问题（找到小于第 k 位的所有元素）</p>
<ol>
<li>根节点就是第 k 位元素的话，就把左子树中的值全部输出出来</li>
<li>第 k 位在左子树中，前 k 位元素全都在左子树中</li>
<li>第 k 位在右子树中，说明根节点和左子树中的元素，都是前 k 位元素里面的值</li>
</ol>
</li>
<li>
<p>二叉排序树和快速排序的关系</p>
<ol>
<li>二叉排序树是快速排序在思维逻辑结构层面用的数据结构</li>
<li>思考1：快速排序的时间复杂度和二叉排序树建树时间复杂度之间的关系</li>
<li>思考2：快速选择算法和二叉排序树之间的关系</li>
<li>程序=算法+数据结构</li>
</ol>
</li>
</ol>
<p>所谓算法设计及分析能力：分类讨论及归纳总结的能力</p>
<p>leetcode</p>
<h2 id="哈希表">哈希表</h2>
<ol>
<li>
<p>映射</p>
</li>
<li>
<p>冲突处理： 哈希之后，所要存储的位置已有元素，有以下几种处理方案；</p>
<ol>
<li>
<p>开放定值法：哈希之后，所要存储的位置已有元素，则沿当前位置往后寻找，直至空位，进行存储；二次探测法等(常用)</p>
</li>
<li>
<p>再哈希法：设置多种哈希函数，当第一种哈希函数冲突时，使用第其余哈希函数进行哈希，从而避免冲突；</p>
</li>
<li>
<p>链表存储：哈希位置存放非单个元素，而是链表，则可以有效避免冲突，现大多采用此种方法避免冲突；（常用）可能会产生数据堆积的后果，浪费空间；</p>
</li>
<li>
<p>建立公共溢出区：将冲突元素全部加入到公共溢出区，避免冲突；</p>
</li>
</ol>
</li>
</ol>
<p>练习题： leetcode 01 03 04 21 35 38 88 217 219 278 349 350 374 378</p>
<p>哈希表的空间利用率通常为50% ~ 90% , 当空间利用率达到70%以上时便可应用于工业。</p>
<p>BKDRhash hash = hash ＊　size  + str[i];</p>
<h2 id="红黑树">红黑树</h2>
<p>与AVL相比，平衡控制更加松散，为的是插入更多的数据，更少的调整。</p>
<h3 id="一-平衡条件">一、平衡条件</h3>
<ol>
<li>每个节点非黑即红</li>
<li>根节点是黑色</li>
<li>叶节点（NIL）是黑色</li>
<li><mark>如果一个节点是红色，则它的两个子节点都是黑色的</mark></li>
<li><mark>从根节点出发到所有叶节点路径上，黑色节点数量相同</mark></li>
</ol>
<p>第4条和第5条条件，决定了红黑树中最长路径是最短路径的长度的2倍。</p>
<p>本质上，红黑树也是通过树高来控制平衡的。</p>
<p>红黑树比AVL树树高控制条件要更加松散，红黑树在发生节点插入和删除以后，发生调整的概率要比AVL树要更小。</p>
<h3 id="二-学习诀窍">二、学习诀窍</h3>
<ol>
<li>理解红黑树的插入调整，要站在<mark>祖父节点</mark>向下调整</li>
<li>理解红黑树的删除调整，要站在<mark>父节点</mark>向下进行调整</li>
<li>插入调整，主要就是为了解决双红情况</li>
<li>新插入的节点一定是红色，插入黑色节点一定会产生冲突，违反条件5，插入红色节点，不一定产生冲突</li>
<li>把每一种情况，想象成一颗大的红黑树中的局部子树</li>
<li>局部调整的时候，为了不影响全局，调整前后的路径上的黑色节点数量相同</li>
</ol>
<h3 id="三-调整策略">三、调整策略</h3>
<p><mark>调整之前路径上黑色节点数量等于调整之后黑色节点的数量</mark></p>
<ol>
<li>插入站在<code>祖父节点</code>看 （参考AVL的调整。同样的树高）</li>
<li>删除调整站在<mark>父节点</mark>看</li>
<li>插入和删除的情况处理一共5种</li>
</ol>
<p>情况一和情况二又可细分4种小情况</p>
<p>LL, RR , RL , LR</p>
<p>情况一</p>
<h3 id="四-插入策略">四、插入策略</h3>
<ol>
<li>叔叔节点为红色的时候，修改三元组小帽子，改成红黑黑。</li>
<li>叔叔节点为黑色的时候，参考AVL失衡情况，分成LL， LR， RL，RR，先参考AVL树的旋转调整策略，然后在修改三元组的颜色，有两种调整策略： 红色上浮，红色下沉。</li>
<li>两大类情况，包含8种小情况。</li>
</ol>
<h3 id="下">（下）</h3>
<p>一、删除调整发生的前提</p>
<ol>
<li>删除红色节点，不会对红黑树的平衡产生影响</li>
<li>度为1的黑色节点，唯一子孩子， 一定是红色。</li>
<li>删除度为1的黑色节点，不会删除</li>
</ol>
<h3 id="红黑树和avl树对比">红黑树和AVL树对比</h3>
<p>查找：AVL更加平衡，所以效率更高</p>
<p>插入：红黑树的调整时更多的进行是染色，左右旋的次数少，提升插入，删除效率。</p>
<p>在工业上插入。</p>
<h2 id="哈夫曼编码">哈夫曼编码</h2>
<h1 id="linux">Linux</h1>
<p>command : &quot;w&quot; display now connection user</p>
<p>向该用户发送你好</p>
<p>echo &quot;hello&quot; &gt;&gt; /dev/pts/1</p>
<p>tr &quot;aaa&quot; &quot;bbb&quot; 将aaa替换成bbb</p>
<h2 id="apt">apt</h2>
<p>apt update （同步软件信息，有哪些软件可用，那些软件可以更新，哪些可以卸载）</p>
<p>apt upgrade （更新本地软件为最新版本）</p>
<p>apt-cache search XXX （搜索xxx软件）</p>
<p>apt remove XXX (删除xxx软件)</p>
<p>apt remove XXX --purge (清除用户信息（彻底删除)</p>
<p>dpkg -i xxx.deb (使用dpkg程序安装xxx.deb) (安装=install -&gt; -i)</p>
<p>dpkg -r (使用dpkg卸载软件) （卸载=remove -&gt; -r)</p>
<p>epoll</p>
<p>man -k xxx</p>
<p>man -f xxx</p>
<p>cat &gt;&gt; a.log &lt;&lt; haha  当输入haha时结束输入</p>
<p>统计登录用户信息，数据清洗</p>
<p>last | grep -v &quot;wtmp begins&quot; | grep -v &quot;^$&quot; | cut -d ' ' -f 1 | sort |  uniq -c |  sort -n -r | head -n 1</p>
<p>-v 取反</p>
<p>^行开始</p>
<p>$行结束</p>
<p>“^$&quot;空行</p>
<p>cut -d ‘ ’ 以空格为分割， -f 1 取第一个</p>
<p>uniq -c 去重并计数</p>
<p>sort -n 以数字大小排序， -r 由大到小输出</p>
<p>head -n x 显示前x行</p>
<p>词频统计</p>
<p>cat xxx | tr -s -c &quot;a-zA-Z&quot; &quot;\n&quot; | sort | uniq -c | sort -n | more</p>
<p>按后面格式输出当前系统时间</p>
<p>date +&quot;%Y-%m-%d %H:%M:%S&quot;</p>
<p>$[] 整数计算</p>
<pre><code class="language-bash">Ontime=`data +&quot;%s&quot;`
echo ${Ontime}
Nowtime=`data + &quot;%s&quot;`
Onlinetime=$[{$Nowtime}-{$Ontime}]
</code></pre>
<p>echo -e &quot;\033[31;34m;34m123\033[0m456&quot;</p>
<p>-e 打开转义</p>
<p>NPT 网络时间协议</p>
<p>特殊变量</p>
<p>$0:获取当前执行shell脚本的文件名，包括路径</p>
<p>$n:获取当前执行脚本的第n个参数，n=1...9, 如果n&gt;9,则需要将n使用{}括起来</p>
<p>$*:获取当前shell的所有参数，将所有命令行参数视为单个字符串，相当于&quot;$1$2$3&quot;;</p>
<p>$#:得到执行当前脚本的参数个数；</p>
<p>$@:获取这个程序所有参数，并保留参数之间的任何空白，相当于&quot;$1&quot; &quot;$2&quot; &quot;$3&quot;,这是将参数传给其他程序的最好办法</p>
<p>$?:判断上一直令是否成功执行，0为成功，非零为不成功</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 13: :取当前进程的PID

$̲!:上一个指令的PID



…'>:取当前进程的PID

$!:上一个指令的PID



read  -s -p prompt  - t 2 xxx

提示prompt 静默输入 超时两秒自动结束

## shell编程

### 函数

```bash
function __printf__() {
	echo &quot;$1&quot;
	return
}

__printf__ &quot;hello handsomeboy&quot;
```



### 条件语句

```bash
#!/bin/bash
read -p &quot;输入任意数字： &quot; a
if [[ ${a} -lt 10 ]];then
    echo &quot;$a &lt; 10&quot;
elif [[ ${a} -eq 10 ]];then
	echo &quot;$a = 10&quot;
else
    echo &quot;$a &gt; 10&quot;
fi

```

### 流程控制

```bash
#!/bin/bash
read a
case $a in
    1)
        echo 1
        ;;
    2)
        echo 2
        ;;
esac
```

### 循环

```bash
#!/bin/bash
for i in `seq 1 100`;do
	touch file${i}.txt
	done
	
```

```bash
#!/bin/bash
num=0
while [[ $num -lt 100 ]];do
    echo ${num}
    num=$[ ${num} + 1 ]
done

```

```bash
#!/bin/bash
num=0
until [[ $num -eq 100 ]];do
    echo $num
    num=$[ ${num} + 1 ]
done

```

```bash
#!/bin/bash
for (( i=1; i&lt;=100; i++ ));do
    if [[ $[ ${i} % 2 ] -eq 0 ]];then
        sum=$[ ${sum} + ${i} ]
    fi
done

echo &quot;sum = ${sum}&quot;

```

### 数组

1. declare -a a
2. name[subscript]=value
3. name=(value1 value2...)

#### 数组操作

1. 输出数组内容

   ${arry[*]}

   ${arry[@]}

2. 确定数组元素个数

   ${#arry[@]}

3. 找到数组的下标

   ${!arry[@]}

4. 数组追加

   arry+=(a b c)

5. 数组排序

   sort

6. 删除数组与元素

   unset



#### 操作实例

```bash
declare -a b
b[1]=1
b[2]=3
echo ${b[@]}
echo ${b[*]}
echo ${#b[*]}

or
c[1]=1
c[2]=2
echo ${c[*]}

or
files=(`ls`)
ehco ${#files[*]} #文件名中有空格时与ls | wc -l结果不同
```

==bash中数组下标不一定连续，可由自己设置离散的数组==







### debug

bash xxx -x 会将每一步都打印出来

在shell脚本内部：

```bash
set +x
kkkkkkk
set -x
```

将kkkkkkk打印出来



### find

杀掉某个用户的全部进程，

```bash
kill `find /proc/ -mmin -10 -user xxx 2&gt;/dev/null | cut -d &#039;/&#039; -f 2 | uniq`
```



查看自己当前目录下所有的代码行数

```bash
find . -name \( &quot;*.c&quot; -o &quot;*.cpp&quot; \) -exec cat {} \; | wc -l

```



### Linux三剑客

#### grep

#### awk

学习参考网站

[学习]: https://awk.readthedocs.io/en/latest/index.html

统计用户登录时长

```bash
last | grep -v &quot;^$&quot; | grep -v &quot;wtmp&quot; | grep -v &quot;still&quot; | awk &#039;{ if ($1 ==  &quot;hhl&quot; ) {print $10} }&#039; | cut -c 2-6 | awk -F: -v hour=0 -v min=0 &#039;{hour+=$1;min+=$2} END{{hour+=(min/60);min=min%60} printf(&quot;%d hours, %d mins\n&quot;,hour,min)}&#039;

```

awk &#039;&#039; 为单引号

#### sed

### 词频统计



## vim操作

批量插入列: 

1. Ctrl + v 进入可视块模式
2. 选中后Shitf+i进入插入模式
3. 输入要插入的内容按ESC进行列插入



# question

## linux 

1. 使用cron设置定时任务
2. Tmux
3. epoll



# Task

## Linux 

### 登录信息提示

1. 在每次通过远程连接进入系统时，告知用户如下信息：
   1. 最近一段时间，当前用户，也就是你，登录了多少次`last`
   2. 上一次登录系统，停留了多少时间
   3. 给用户推荐一句名人名言，唐诗三百首之类的
   4. 最好还能告知一下当地当日天气预报
   5. 一个温馨的问候，毕竟是==女朋友==
2. 要求显示美观，有一定的颜色

#### 完成过程

1. 使用man zsh (/FILE)查询启动zsh时的相关文件
2. 修改相关的ZSH文件</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
<ul>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">二叉排序树</a>
<ul>
<li><a href="#%E4%B8%80-%E6%80%A7%E8%B4%A8">一、性质</a></li>
<li><a href="#%E4%BA%8C-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">二、插入操作</a></li>
<li><a href="#%E4%B8%89-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">三、删除操作</a></li>
<li><a href="#%E5%9B%9B-%E9%9A%8F%E5%A0%82%E7%BB%83%E4%B9%A0">四、随堂练习</a></li>
<li><a href="#%E4%BA%94-%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9">五、扩展内容</a></li>
</ul>
</li>
<li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a></li>
<li><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>
<ul>
<li><a href="#%E4%B8%80-%E5%B9%B3%E8%A1%A1%E6%9D%A1%E4%BB%B6">一、平衡条件</a></li>
<li><a href="#%E4%BA%8C-%E5%AD%A6%E4%B9%A0%E8%AF%80%E7%AA%8D">二、学习诀窍</a></li>
<li><a href="#%E4%B8%89-%E8%B0%83%E6%95%B4%E7%AD%96%E7%95%A5">三、调整策略</a></li>
<li><a href="#%E5%9B%9B-%E6%8F%92%E5%85%A5%E7%AD%96%E7%95%A5">四、插入策略</a></li>
<li><a href="#%E4%B8%8B">（下）</a></li>
<li><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91%E5%AF%B9%E6%AF%94">红黑树和AVL树对比</a></li>
</ul>
</li>
<li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">哈夫曼编码</a></li>
</ul>
</li>
<li><a href="#linux">Linux</a>
<ul>
<li><a href="#apt">apt</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://haizei.github.io/post/rqwr/">
              <h3 class="post-title">
                rqwr 
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://haizei.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
